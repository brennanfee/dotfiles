#!/usr/bin/env bash
# Author: Brennan Fee
# License: MIT License
#
# This script sets up a new Debian repo.  It is to replace the deprecated pattern of
# using add-apt-key and instead downloads the key and sets the sources file to point
# to the downloaded key.  Most often the only two required parameters are the path or
# URL to the key, and the url for the deb repository.  However, many other options are
# provided to override certain defaults.

# Bash strict mode
([[ -n ${ZSH_EVAL_CONTEXT:-} && ${ZSH_EVAL_CONTEXT:-} =~ :file$ ]] ||
  [[ -n ${BASH_VERSION:-} ]] && (return 0 2>/dev/null)) && SOURCED=true || SOURCED=false
if ! ${SOURCED}; then
  set -o errexit  # same as set -e
  set -o nounset  # same as set -u
  set -o errtrace # same as set -E
  set -o pipefail
  set -o posix
  #set -o xtrace # same as set -x, turn on for debugging

  shopt -s inherit_errexit
  shopt -s extdebug
  IFS=$(printf '\n\t')
fi
# END Bash strict mode

AUTHOR="Brennan A. Fee"
VERSION="0.1 2023-06-15"

KEY_FILE=""
REPO_URL=""
KEY_PATH="/usr/local/share/keyrings"
# override for the application name the repo belongs to, defaults to the key filename
# without extension
APP_NAME=""
# override of the output key file name, otherwise same as input
OUTPUT_KEY_FILE=""
# override of the sources list file name, otherwise same as key file name
SOURCES_FILENAME=""
# whether to include deb-src version of the repo
SOURCES_INCLUDE_SRC=0
# override of the sources list distribution, otherwise will use systems
SOURCES_DISTRIBUTION="$(lsb_release -c -s)"
# override of the sources list components
SOURCES_COMPONENTS="main"
# override gpg exe location
GPG_BIN=""
# idempotent state, present, absent, latest
STATE="present"
# whether help was specifically requested to be shown
HELP_REQUESTED=0

SUPPORTED_STATES=("present" "absent" "latest")
DEFAULT_GPG_BIN="/usr/bin/gpg"
GPG_BIN_EXE=""

APP_NAME=""
KEY_FILE_FULLPATH=""
SOURCES_FILE_FULLPATH=""

FILES_PRESENT=0

#### START: Utility methods

# Text modifiers
TEXT_RESET="$(tput sgr0)"
TEXT_RED="$(tput setaf 1)"
TEXT_YELLOW="$(tput setaf 3)"

blank_line() {
  echo ""
}

print_status() {
  local T_COLS
  T_COLS=$(tput cols)
  T_COLS=$((T_COLS - 1))
  echo -e "$1${TEXT_RESET}" | fold -sw "${T_COLS}"
}

print_warning() {
  local T_COLS
  T_COLS=$(tput cols)
  T_COLS=$((T_COLS - 1))
  echo -e "${TEXT_YELLOW}$1${TEXT_RESET}" | fold -sw "${T_COLS}"
}

print_error() {
  local T_COLS
  T_COLS=$(tput cols)
  T_COLS=$((T_COLS - 1))
  echo -e "${TEXT_RED}$1${TEXT_RESET}" | fold -sw "${T_COLS}"
}

error_msg() {
  print_error "$1"
  if [[ ${2:-} != "" ]]; then
    exit "$2"
  else
    exit 1
  fi
}

get_exit_code() {
  EXIT_CODE=0
  # We first disable errexit in the current shell
  set +e
  (
    # Then we set it again inside a subshell
    set -e
    # ...and run the function
    "$@"
  )
  # shellcheck disable=2034
  EXIT_CODE=$?
  # And finally turn errexit back on in the current shell
  set -e
}

contains_element() {
  #check if an element exist in a string
  for e in "${@:2}"; do
    [[ ${e} == "$1" ]] && break
  done
}

#### END: Utility methods

check_root() {
  local user_id
  user_id=$(id -u)
  if [[ "${user_id}" != "0" ]]; then
    error_msg "ERROR! You must execute the script as the 'root' user."
  fi
}

show_help() {
  if [[ "${HELP_REQUESTED}" == "0" ]]; then
    print_warning "Incorrect parameters or options provided."
    blank_line
  fi

  print_status "deb-add-repo Help"
  print_status "Version: ${VERSION}    Author: ${AUTHOR}"
  blank_line
  print_status "  deb-add-repo [options] <key file or url> <repo url>"
  blank_line
  print_status "This program sets up a Debian (or derivative) repository using the new method of"
  print_status "downloading a GPG key and setting up the sources.list.d file to use the 'signed-by'"
  print_status "setting to indicate the repo is signed by that key.  This replaces the older"
  print_status "method of using 'apt-key' to add the keys globally.  This method is more secure."
  blank_line
  print_status "Prerequisites:  lsb_release, gnupg, and wget must all be installed or accessible."
  blank_line
  print_status "Options:"
  blank_line
  print_status "  -h or --help"
  print_status "      Show this help screen."
  blank_line
  print_status "  -v or --version"
  print_stauts "     Show the version number."
  blank_line
  print_status "  --gpg-bin-path <path>"
  print_status "      Location where the gpg executable can be found.  By default, it looks using"
  print_status "      the system path and if not found in the path then attempts to use "
  print_status "      /usr/bin/gpg.  If your GPG setup is somehow different and not in your path,"
  print_status "      you will need to provide a valid path here."
  blank_line
  print_status "  --app-name <string>"
  print_status "      The application name the repo is intended for.  Will default to the filename"
  print_stauts "      of the key file without extension."
  blank_line
  print_status "  --key-path <path>"
  print_status "      Location where the key file will be placed. Default is "
  print_status "      /usr/local/share/keyrings."
  blank_line
  print_status "  --output-key-name <filename>"
  print_status "      Key filename to use, otherwise will default to the downloaded file name."
  print_status "      This should end in '.gpg', if it doesn't .gpg will be added automatically."
  blank_line
  print_status "  --sources-name <filename>"
  print_status "      Name of the APT sources list file, otherwise will default to the downloaded"
  print_status "      file name of the key."
  blank_line
  print_status "  -i or --include-sources"
  print_status "      Toggle to include deb-src in the sources file. Default is to not include it."
  blank_line
  print_status "  --sources-distribution <string>"
  print_status "      Override for the distribution name to use, will default to the current"
  print_status "      systems distribution version codename."
  blank_line
  print_status "  --sources-components <string>"
  print_status "      The components of packages to include, defaults to just 'main'.  This is a"
  print_status "      space separated list so you will likely need to wrap this in quotes."
  blank_line
  print_status "  --state <present/absent/latest>"
  print_status "      To support idempotent execution.  The default is 'present' and will do nothing"
  print_status "      if the key and sources file already exist.  'Absent' will remove them or do"
  print_status "      nothing.  Latest will still pull the key down and re-install it even if the"
  print_status "      files are present, ensuring you have the latest signing key for the repo."

  if [[ "${HELP_REQUESTED}" == "0" ]]; then
    exit 1
  else
    exit 0
  fi
}

show_version() {
  print_status "deb-add-repo"
  print_status "Version: ${VERSION}    Author: ${AUTHOR}"
  exit 0
}

ARGS=$(getopt -n "deb-add-repo" --options "vhis:" --longoptions "version,help,include-sources,state:,app-name:,key-path:,gpg-bin-path:,output-key-name:,sources-name:,sources-distribution:,sources-components:" -- "$@")

# Show help if no parameters were passed
# shellcheck disable=SC2181
if [[ $? -ne 0 ]]; then
  show_help
fi

eval set -- "${ARGS}"
unset ARGS

while true; do
  case "$1" in
  '-h' | '--help')
    HELP_REQUESTED=1
    show_help
    ;;
  '-v' | '--version')
    show_version
    ;;
  '-i' | '--include-sources')
    SOURCES_INCLUDE_SRC=1
    shift
    continue
    ;;
  '-s' | '--state')
    STATE=$(echo "$2" | tr "[:upper:]" "[:lower:]")
    shift 2
    continue
    ;;
  '--app-name')
    APP_NAME="$2"
    shift 2
    continue
    ;;
  '--key-path')
    KEY_PATH="$2"
    shift 2
    continue
    ;;
  '--gpg-bin-path')
    GPG_BIN="$2"
    shift 2
    continue
    ;;
  '--output-key-name')
    OUTPUT_KEY_FILE="$2"
    shift 2
    continue
    ;;
  '--sources-name')
    SOURCES_FILENAME="$2"
    shift 2
    continue
    ;;
  '--sources-distribution')
    SOURCES_DISTRIBUTION="$2"
    shift 2
    continue
    ;;
  '--sources-components')
    SOURCES_COMPONENTS="$2"
    shift 2
    continue
    ;;
  '--')
    shift
    break
    ;;
  *)
    error_msg "Unknown option: $1"
    ;;
  esac
done

ARG_COUNT=1
for arg; do
  case "${ARG_COUNT}" in
  1)
    KEY_FILE=${arg}
    ;;
  2)
    REPO_URL=$(echo "${arg}" | tr "[:upper:]" "[:lower:]")
    ;;
  3)
    break
    ;;
  *)
    error_msg "Internal Argument Error"
    ;;
  esac
  ARG_COUNT=$((ARG_COUNT + 1))
done

verify_state() {
  get_exit_code contains_element "${STATE}" "${SUPPORTED_STATES[@]}"
  if [[ ! "${EXIT_CODE}" == "0" ]]; then
    error_msg "Invalid 'State' argument value. Use one of 'present', 'absent', or 'latest'."
  fi
}

set_gpg_exe() {
  if [[ "${GPG_BIN}" == "" || ! -x "${GPG_BIN}" ]]; then
    if command -v "gpg" &>/dev/null; then
      GPG_BIN_EXE=$(command -v gpg)
    elif [[ -x "${DEFAULT_GPG_BIN}" ]]; then
      GPG_BIN_EXE="${DEFAULT_GPG_BIN}"
    else
      local msg="Unable to locate GPG executable.  Make sure GnuGPG is installed and either"
      msg="${msg} on your path or you pass in the location with --gpg-bin."
      error_msg "${msg}"
    fi
  else
    GPG_BIN_EXE="${GPG_BIN}"
  fi
}

verify_parameters() {
  verify_state
  set_gpg_exe

  if [[ "${KEY_FILE:-}" == "" ]]; then
    error_msg "A key file must be provided."
  fi

  if [[ "${REPO_URL:-}" == "" ]]; then
    error_msg "A repo URL must be provided."
  fi
}

determine_file_names() {
  local key_name
  key_name="$(basename "${KEY_FILE}")"
  if [[ "${key_name}" == *.key ]]; then
    key_name="${key_name:1:-4}"
  fi

  if [[ ${OUTPUT_KEY_FILE:-} != "" ]]; then
    key_name="${OUTPUT_KEY_FILE}"
  elif [[ ${APP_NAME} != "" ]]; then
    key_name="${APP_NAME}"
  fi

  if [[ "${key_name}" == *.gpg ]]; then
    key_name="${key_name:1:-4}"
  fi

  APP_NAME="${key_name}"
  KEY_FILE_FULLPATH="${KEY_PATH}/${key_name}.gpg"

  if [[ "${SOURCES_FILENAME:-}" != "" ]]; then
    local src_file="${SOURCES_FILENAME}"
    if [[ "${src_file}" != *.list ]]; then
      src_file="${src_file}.list"
    fi

    SOURCES_FILE_FULLPATH="/etc/apt/sources.list.d/${src_file}"
  else
    SOURCES_FILE_FULLPATH="/etc/apt/sources.list.d/${key_name}.list"
  fi
}

check_files_present() {
  determine_file_names

  if [[ -f "${SOURCES_FILE_FULLPATH}" || -f "${KEY_FILE_FULLPATH}" ]]; then
    FILES_PRESENT=1
  else
    FILES_PRESENT=0
  fi
}

remove_files() {
  if [[ -f "${SOURCES_FILE_FULLPATH}" ]]; then
    rm "${SOURCES_FILE_FULLPATH}"
  fi

  if [[ -f "${KEY_FILE_FULLPATH}" ]]; then
    rm "${KEY_FILE_FULLPATH}"
  fi
}

setup_key() {
  local tmp_file
  local file_type
  local tmp_keyring
  tmp_file=$(mktemp)

  if [[ "${KEY_FILE}" == http://* || "${KEY_FILE}" == https://* ]]; then
    wget -q -O "${tmp_file}" "${KEY_FILE}"
  else
    cp "${KEY_FILE}" "${tmp_file}"
  fi

  # Create the key file path if it doesn't already exist
  mkdir -p "${KEY_PATH}"

  # Check the file type
  file_type=$(file -b "${tmp_file}")

  # Handle the different GPG key types
  if [[ "${file_type}" == "PGP public key block Public-Key (old)" ]]; then
    "${GPG_BIN_EXE}" --batch --yes --dearmor --keyring=gnupg-ring "${tmp_file}"
    cp "${tmp_file}.gpg" "${KEY_FILE_FULLPATH}"
  elif [[ "${file_type}" == "PGP public key block Secret-Key" ]]; then
    tmp_keyring=$(mktemp)

    "${GPG_BIN_EXE}" --batch --yes --no-default-keyring --keyring=gnupg-ring:"\"${tmp_keyring}\"" \
      --quiet --import "${tmp_file}"

    "${GPG_BIN_EXE}" --batch --yes --no-default-keyring --keyring=gnupg-ring:"\"${tmp_keyring}\"" \
      --export --output "${KEY_FILE_FULLPATH}"

    if [[ -f "${tmp_keyring}" ]]; then
      rm "${tmp_keyring}"
    fi
  elif [[ "${file_type}" == "PGP/GPG key public ring (v4)" ]]; then
    cp "${tmp_file}" "${KEY_FILE_FULLPATH}"
  else
    error_msg "Invalid key file type."
  fi

  if [[ -f "${tmp_file}" ]]; then
    rm "${tmp_file}"
  fi
  chmod "0644" "${KEY_FILE_FULLPATH}"
}

setup_sources_file() {
  local arch
  local repo_line

  repo_line="[arch=${arch} signed-by=${KEY_FILE_FULLPATH}] ${REPO_URL} ${SOURCES_DISTRIBUTION}"
  repo_line="${repo_line} ${SOURCES_COMPONENTS}"

  if [[ -f "${SOURCES_FILE_FULLPATH}" ]]; then
    rm "${SOURCES_FILE_FULLPATH}"
  fi

  {
    echo "# Sources for: ${APP_NAME}"
    echo "# vim: set ft=debsources :"
    echo ""
    echo "deb ${repo_line}"
  } >"${SOURCES_FILE_FULLPATH}"

  if [[ "${SOURCES_INCLUDE_SRC}" == "1" ]]; then
    echo "deb-src ${repo_line}" >>"${SOURCES_FILE_FULLPATH}"
  fi

  chmod "0644" "${SOURCES_FILE_FULLPATH}"
}

download_and_setup() {
  setup_key
  setup_sources_file
}

main() {
  check_root
  verify_parameters

  check_files_present

  case "${STATE}" in
  'present')
    if [[ "${FILES_PRESENT}" == "0" ]]; then
      download_and_setup
    fi
    ;;
  'absent')
    if [[ "${FILES_PRESENT}" == "1" ]]; then
      remove_files
    fi
    ;;
  'latest')
    download_and_setup
    ;;
  *)
    error_msg "Invalid Argument Error: Invalid State"
    ;;
  esac

  exit 0
}

main "$@"
