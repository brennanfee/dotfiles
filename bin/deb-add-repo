#!/usr/bin/env bash
#
# This script sets up a new Debian repo.  It is to replace the deprecated pattern of
# using add-apt-key and instead downloads the key and sets the sources file to point
# to the downloaded key.  Most often the only two required parameters are the path or
# URL to the key, and the url for the deb repository.  However, many other options are
# provided to override certain defaults.

### START Bash strict mode
# shellcheck disable=SC2154
([[ -n ${ZSH_EVAL_CONTEXT} && ${ZSH_EVAL_CONTEXT} =~ :file$ ]] ||
  [[ -n ${BASH_VERSION} ]] && (return 0 2>/dev/null)) && SOURCED=true || SOURCED=false
if ! ${SOURCED}; then
  set -o errexit  # same as set -e
  set -o nounset  # same as set -u
  set -o errtrace # same as set -E
  set -o pipefail
  set -o posix
  #set -o xtrace # same as set -x, turn on for debugging

  shopt -s extdebug
  IFS=$(printf '\n\t')
fi
### END Bash strict mode

### START Script template bootstrap

script_name=$(basename "${BASH_SOURCE[0]}")
script_dir="$(realpath "$(dirname "${BASH_SOURCE[0]}")")"
script_author="Brennan Fee"
script_license="MIT License"
script_version="0.3"
script_date="2024-09-16"

function cleanup_vars() {
  unset script_name
  unset script_dir
  unset script_author
  unset script_license
  unset script_version
  unset script_date

  cleanup_script_vars
}

# Source script-tools.bash
if [[ -f "${script_dir}/../bash/script-tools.bash" ]]; then
  # shellcheck source=/home/brennan/.dotfiles/bash/script-tools.bash
  source "${script_dir}/../bash/script-tools.bash"
fi

function show_version() {
  print_status "${script_name}"
  print_status "Author: ${script_author} --- License: ${script_license}"
  print_status "Version: ${script_version} --- Date: ${script_date}"
  print_blank_line

  if [[ "${1:-}" == "exit" || "${1:-}" == "yes" ]]; then
    exit 0
  fi
}

### END Script template bootstrap

KEY_FILE=""
REPO_URL=""
KEY_PATH="/etc/apt/keyrings"
# override for the application name the repo belongs to, defaults to the key filename
# without extension
APP_NAME=""
# override of the output key file name, otherwise same as input
OUTPUT_KEY_FILE=""
# override of the sources list file name, otherwise same as key file name
SOURCES_FILENAME=""
# whether to include deb-src version of the repo
SOURCES_INCLUDE_SRC=0
# override of the sources list distribution, otherwise will use systems
SOURCES_DISTRIBUTION="$(lsb_release -c -s)"
# override of the sources list components
SOURCES_COMPONENTS="main"
# override gpg exe location
GPG_BIN=""
# idempotent state, present, absent, latest
STATE="present"
# whether help was specifically requested to be shown
HELP_REQUESTED=0

SUPPORTED_STATES=("present" "absent" "latest")
DEFAULT_GPG_BIN="/usr/bin/gpg"
GPG_BIN_EXE=""

KEY_FILE_FULLPATH=""
SOURCES_FILE_FULLPATH=""

FILES_PRESENT=0

function cleanup_script_vars() {
  unset KEY_FILE
  unset REPO_URL
  unset KEY_PATH
  unset APP_NAME
  unset OUTPUT_KEY_FILE
  unset SOURCES_FILENAME
  unset SOURCES_INCLUDE_SRC
  unset SOURCES_DISTRIBUTION
  unset SOURCES_COMPONENTS
  unset GPG_BIN
  unset STATE
  unset HELP_REQUESTED
  unset SUPPORTED_STATES
  unset DEFAULT_GPG_BIN
  unset GPG_BIN_EXE
  unset KEY_FILE_FULLPATH
  unset SOURCES_FILE_FULLPATH
  unset FILES_PRESENT
}

function process_arguments() {
  local args
  args=$(getopt -n "${script_name}" --options "vhis:" --longoptions "version,help,include-sources,state:,app-name:,key-path:,gpg-bin-path:,output-key-name:,sources-name:,sources-distribution:,sources-components:" -- "$@")

  # Show help if no parameters were passed
  #
  # shellcheck disable=SC2181
  if [[ $? -ne 0 ]]; then
    show_help
  fi

  eval set -- "${args}"

  # Process flags and options
  #
  while true; do
    case "$1" in
    '-h' | '--help')
      HELP_REQUESTED=1
      show_help
      ;;
    '-v' | '--version')
      show_version "exit"
      ;;
    '-i' | '--include-sources')
      SOURCES_INCLUDE_SRC=1
      shift
      continue
      ;;
    '-s' | '--state')
      STATE=$(echo "$2" | tr "[:upper:]" "[:lower:]")
      shift 2
      continue
      ;;
    '--app-name')
      APP_NAME="$2"
      shift 2
      continue
      ;;
    '--key-path')
      KEY_PATH="$2"
      shift 2
      continue
      ;;
    '--gpg-bin-path')
      GPG_BIN="$2"
      shift 2
      continue
      ;;
    '--output-key-name')
      OUTPUT_KEY_FILE="$2"
      shift 2
      continue
      ;;
    '--sources-name')
      SOURCES_FILENAME="$2"
      shift 2
      continue
      ;;
    '--sources-distribution')
      SOURCES_DISTRIBUTION="$2"
      shift 2
      continue
      ;;
    '--sources-components')
      SOURCES_COMPONENTS="$2"
      shift 2
      continue
      ;;
    '--')
      shift
      break
      ;;
    *)
      throw_error_msg "Unknown option: $1"
      ;;
    esac
  done

  # Process positional arguments
  #
  local arg_count=1
  for arg; do
    case "${arg_count}" in
    1)
      KEY_FILE=${arg}
      ;;
    2)
      REPO_URL=$(echo "${arg}" | tr "[:upper:]" "[:lower:]")
      ;;
    3)
      break
      ;;
    *)
      throw_error_msg "Internal Argument Error"
      ;;
    esac
    arg_count=$((arg_count + 1))
  done
}

#### START: Help

function show_help() {
  if [[ "${HELP_REQUESTED}" == "0" ]]; then
    print_warning "Incorrect parameters or options provided."
    print_blank_line
  fi

  show_version ""

  print_status "  ${script_name} [options] <key file or url> <repo url>"
  print_blank_line
  print_status "This program sets up a Debian (or derivative) repository using the new method of"
  print_status "downloading a GPG key and setting up the sources.list.d file to use the 'signed-by'"
  print_status "setting to indicate the repo is signed by that key.  This replaces the older"
  print_status "method of using 'apt-key' to add the keys globally.  This method is more secure."
  print_blank_line
  print_status "Prerequisites:  lsb_release, gnupg, and wget must all be installed or accessible."
  print_blank_line
  print_status "Options:"
  print_blank_line
  print_status "  -h or --help"
  print_status "      Show this help screen."
  print_blank_line
  print_status "  -v or --version"
  print_status "     Show the version number."
  print_blank_line
  print_status "  --gpg-bin-path <path>"
  print_status "      Location where the gpg executable can be found.  By default, it looks using"
  print_status "      the system path and if not found in the path then attempts to use "
  print_status "      /usr/bin/gpg.  If your GPG setup is somehow different and not in your path,"
  print_status "      you will need to provide a valid path here."
  print_blank_line
  print_status "  --app-name <string>"
  print_status "      The application name the repo is intended for.  Will default to the filename"
  print_status "      of the key file without extension."
  print_blank_line
  print_status "  --key-path <path>"
  print_status "      Location where the key file will be placed. Default is "
  print_status "      /usr/local/share/keyrings."
  print_blank_line
  print_status "  --output-key-name <filename>"
  print_status "      Key filename to use, otherwise will default to the downloaded file name."
  print_status "      This should end in '.gpg', if it doesn't .gpg will be added automatically."
  print_blank_line
  print_status "  --sources-name <filename>"
  print_status "      Name of the APT sources list file, otherwise will default to the downloaded"
  print_status "      file name of the key."
  print_blank_line
  print_status "  -i or --include-sources"
  print_status "      Toggle to include deb-src in the sources file. Default is to not include it."
  print_blank_line
  print_status "  --sources-distribution <string>"
  print_status "      Override for the distribution name to use, will default to the current"
  print_status "      systems distribution version codename."
  print_blank_line
  print_status "  --sources-components <string>"
  print_status "      The components of packages to include, defaults to just 'main'.  This is a"
  print_status "      space separated list so you will likely need to wrap this in quotes."
  print_blank_line
  print_status "  --state <present/absent/latest>"
  print_status "      To support idempotent execution.  The default is 'present' and will do nothing"
  print_status "      if the key and sources file already exist.  'Absent' will remove them or do"
  print_status "      nothing.  Latest will still pull the key down and re-install it even if the"
  print_status "      files are present, ensuring you have the latest signing key for the repo."

  if [[ "${HELP_REQUESTED}" == "0" ]]; then
    exit 1
  else
    exit 0
  fi
}

#### END: Help

function verify_state() {
  get_exit_code contains_element "${STATE}" "${SUPPORTED_STATES[@]}"
  if [[ ! "${EXIT_CODE}" == "0" ]]; then
    throw_error_msg "Invalid 'State' argument value. Use one of 'present', 'absent', or 'latest'."
  fi
}

function set_gpg_exe() {
  if [[ "${GPG_BIN}" == "" || ! -x "${GPG_BIN}" ]]; then
    if command -v "gpg" &>/dev/null; then
      GPG_BIN_EXE=$(command -v gpg)
    elif [[ -x "${DEFAULT_GPG_BIN}" ]]; then
      GPG_BIN_EXE="${DEFAULT_GPG_BIN}"
    else
      local msg="Unable to locate GPG executable.  Make sure GnuGPG is installed and either"
      msg="${msg} on your path or you pass in the location with --gpg-bin."
      throw_error_msg "${msg}"
    fi
  else
    GPG_BIN_EXE="${GPG_BIN}"
  fi
}

function ensure_key_path() {
  mkdir -p "${KEY_PATH}"
  chmod "0755" "${KEY_PATH}"
}

verify_parameters() {
  verify_state
  set_gpg_exe
  ensure_key_path

  if [[ "${KEY_FILE:-}" == "" ]]; then
    throw_error_msg "A key file must be provided."
  fi

  if [[ "${REPO_URL:-}" == "" ]]; then
    throw_error_msg "A repo URL must be provided."
  fi
}

determine_file_names() {
  local key_name
  key_name="$(basename "${KEY_FILE}")"
  if [[ "${key_name}" == *.key ]]; then
    key_name="${key_name:1:-4}"
  fi

  if [[ ${OUTPUT_KEY_FILE:-} != "" ]]; then
    key_name="${OUTPUT_KEY_FILE}"
  elif [[ ${APP_NAME} != "" ]]; then
    key_name="${APP_NAME}"
  fi

  if [[ "${key_name}" == *.gpg ]]; then
    key_name="${key_name:1:-4}"
  fi

  APP_NAME="${key_name}"
  KEY_FILE_FULLPATH="${KEY_PATH}/${key_name}.gpg"

  if [[ "${SOURCES_FILENAME:-}" != "" ]]; then
    local src_file="${SOURCES_FILENAME}"
    if [[ "${src_file}" != *.list ]]; then
      src_file="${src_file}.list"
    fi

    SOURCES_FILE_FULLPATH="/etc/apt/sources.list.d/${src_file}"
  else
    SOURCES_FILE_FULLPATH="/etc/apt/sources.list.d/${key_name}.list"
  fi
}

check_files_present() {
  determine_file_names

  if [[ -f "${SOURCES_FILE_FULLPATH}" || -f "${KEY_FILE_FULLPATH}" ]]; then
    FILES_PRESENT=1
  else
    FILES_PRESENT=0
  fi
}

remove_files() {
  if [[ -f "${SOURCES_FILE_FULLPATH}" ]]; then
    rm "${SOURCES_FILE_FULLPATH}"
  fi

  if [[ -f "${KEY_FILE_FULLPATH}" ]]; then
    rm "${KEY_FILE_FULLPATH}"
  fi
}

setup_key() {
  local tmp_file
  local file_type
  local tmp_keyring
  tmp_file=$(mktemp)

  if [[ "${KEY_FILE}" == http://* || "${KEY_FILE}" == https://* ]]; then
    wget -q -O "${tmp_file}" "${KEY_FILE}"
  else
    cp "${KEY_FILE}" "${tmp_file}"
  fi

  # Check the file type
  file_type=$(file -b "${tmp_file}")

  # Handle the different GPG key types
  if [[ "${file_type}" == "PGP public key block Public-Key (old)" ]]; then
    "${GPG_BIN_EXE}" --batch --yes --dearmor --keyring=gnupg-ring "${tmp_file}"
    cp "${tmp_file}.gpg" "${KEY_FILE_FULLPATH}"
  elif [[ "${file_type}" == "PGP public key block Secret-Key" ]]; then
    tmp_keyring=$(mktemp)

    "${GPG_BIN_EXE}" --batch --yes --no-default-keyring --keyring=gnupg-ring:"\"${tmp_keyring}\"" \
      --quiet --import "${tmp_file}"

    "${GPG_BIN_EXE}" --batch --yes --no-default-keyring --keyring=gnupg-ring:"\"${tmp_keyring}\"" \
      --export --output "${KEY_FILE_FULLPATH}"

    if [[ -f "${tmp_keyring}" ]]; then
      rm "${tmp_keyring}"
    fi
  elif [[ "${file_type}" == "PGP/GPG key public ring (v4)" ]]; then
    cp "${tmp_file}" "${KEY_FILE_FULLPATH}"
  else
    throw_error_msg "Invalid key file type."
  fi

  if [[ -f "${tmp_file}" ]]; then
    rm "${tmp_file}"
  fi
  chmod "0644" "${KEY_FILE_FULLPATH}"
}

setup_sources_file() {
  local arch
  local repo_line

  repo_line="[arch=${arch} signed-by=${KEY_FILE_FULLPATH}] ${REPO_URL} ${SOURCES_DISTRIBUTION}"
  repo_line="${repo_line} ${SOURCES_COMPONENTS}"

  if [[ -f "${SOURCES_FILE_FULLPATH}" ]]; then
    rm "${SOURCES_FILE_FULLPATH}"
  fi

  {
    echo "# Sources for: ${APP_NAME}"
    echo "# vim: set ft=debsources :"
    echo ""
    echo "deb ${repo_line}"
  } >"${SOURCES_FILE_FULLPATH}"

  if [[ "${SOURCES_INCLUDE_SRC}" == "1" ]]; then
    echo "deb-src ${repo_line}" >>"${SOURCES_FILE_FULLPATH}"
  fi

  chmod "0644" "${SOURCES_FILE_FULLPATH}"
}

download_and_setup() {
  setup_key
  setup_sources_file
}

function main() {
  check_root_with_error ""
  verify_parameters

  check_files_present

  case "${STATE}" in
  'present')
    if [[ "${FILES_PRESENT}" == "0" ]]; then
      download_and_setup
    fi
    ;;
  'absent')
    if [[ "${FILES_PRESENT}" == "1" ]]; then
      remove_files
    fi
    ;;
  'latest')
    download_and_setup
    ;;
  *)
    throw_error_msg "Invalid Argument Error: Invalid State"
    ;;
  esac
}

### START Script main handler

function main_handler() {
  local args=("$@")
  process_arguments "$@"

  main "${args[@]}"
  cleanup_vars
}

main_handler "$@"

### END Script main handler
